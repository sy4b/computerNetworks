# 2.1 数制和数码
## 2.1.1 进位计数制及其相互转换
计算机内部所有信息都用二进制进行编码，原因在于：
1. 二进制只有两种状态，使用具有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本低
2. 二进制位1和0正好和逻辑“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供便利
3. 二进制编码和运算规则简单，通过逻辑门电路能方便地实现算术运算
### 进位计数法
常用十进制、二进制、八进制、十六进制
基数：每个数位用到不同数码个数称。例如十进制的基数为10
位权
一个$r$进制数$K_nK_{n-1}K_{n-2}...K_0K_{-1}...K_{-m}$的数值可以表示为
$K_n*r^n+K_{n-1}*r^{n-1}+K_{n-2}*r^{n-2}+...+K_{-m}*r^{-m}=\Sigma_{i=n}^{-m}K_i*r^i$
$r$为基数，$r^i$为第$i$位的位权

> $2^{16}=65536$
> $2^{15}=32768$

### 不同进制数的相互转换
#### 二进制转换为八进制和十六进制
一位八进制对应三位二进制
一位十六进制对应四位二进制
```
1111000010.01101 转换为八进制和十六进制

00)11_1100_0010.0110_1(000 -> 3C2.68

00)1_111_000_010.011_01(0 -> 1702.32
```
#### 任意进制数转换为十进制数
各位数码和他们的权值相乘，再把乘积相加，即可得到十进制数——按权展开相加
```
0b11011.1 = 16+8+2+1+0.5 = 27.5
```
#### 十进制转换为任意进制数
1. 对于整数，采用除基取余法，结果倒着写
2. 对于小数，采用乘基取整法，结果正着写
```
123.6875转换为二进制数

整数部分123:
2|__123...1
2|___61...1
2|___30...0
2|___15...1
2|____7...1
2|____3...1
2|____1...1
      0
123 = 0b1111011

小数部分0.6875:
0.6875
*    2
______
1.3750			1
0.375
*   2
_____
0.75			0
*  2 
____
1.5				1
0.5
* 2
___
1				1
0
0.6875 = 0b0.1011

综上123.6875 = 0b1111011.1011
```
小数是离散的，**并不是每个十进制数都可以准确地用二进制数表示**，但每个二进制小数都可以用十进制表示
### 真值和机器数
真值是机器数所代表的实际值
## 2.1.2 BCD码（大纲已删除
四位二进制数表示一位十进制数。4位二进制可组合成16种情况，因此有6种冗余
1. 8421码：有权码，位权分别为8 4 2 1。**两个8421码相加结果大于1001，需要加6修正**
2. 2421码，有权码，位权分别为2 4 2 1。**大于等于5的数最高位为1；小于5的数最高位为0**（5的2421码为1011而不是0101
3. 余3码：无权码，在8421码的基础上加上0011
## 2.1.3 定点数的编码表示
定点数：小数点的位置固定的数
反之为浮点数
### 机器数的定点表示
定点表示法用来表示定点小数和定点整数。
1. 定点小数：**纯小数，约定小数点在符号位之后，有效数值部分最高位之前**
2. 定点整数：**纯整数，小数点在有效数值部分最低位之后**

定点数编码表示法主要有以下四种：**原码、补码、反码和移码**
### 原码、补码、反码和移码
#### 原码表示法
**机器数最高位表示数的符号，其余各位表示数的绝对值**
字长$n+1$位的原码小数可以表示的范围是：$-(1-2^{-n})\leq{x}\leq{1-2^{-n}}$
字长$n+1$位的原码整数可以表示的范围是：$-(2^{n}-1)\leq{x}\leq{2^{n}-1}$

真值0的原码有+0和-0两种表示
#### 补码表示法
**补码表示法的加减运算统一采用加法操作实现**
字长$n+1$位的补码小数可以表示的范围是：$-1\leq{x}\leq{1-2^{-n}}$
字长$n+1$位的补码整数可以表示的范围是：$-(2^{n})\leq{x}\leq{2^{n}-1}$

0的补码是唯一的

**原码->补码：正数的补码等于原码，负数则符号位不变，其余各位取反，最后+1**

> 1. $[x]_补->[-x]_补$的方法：$[x]_补$连同符号位取反，再+1
> 2. 补码表示中，符号位相同的情况下，数值位越大，码值越大
> 3. （10真题）假设4个整数用8位补码表示，分别为$r_1$=FEH, $r_2$=F2H, $$r_3$=90H, $r_4$=F8H，若结果放在一个8位寄存器中，则两数相乘会溢出的是：（考察8位补码的表示范围：-128～127）

#### 变形补码
又称**模4补码**，采用双符号位
**00表示正，11表示负**
**符号位和数值位一起右移并保持符号位不变，可以实现除法功能**
> 1. 模4补码存储时只需要一个符号位
#### 反码表示法
负数的补码 = 原码符号位不变，其余各位取反
反码很少在计算机中使用，通常用作数码变换的中间表示形式
#### 移码表示法
**移码通常用来表示浮点数的阶码，只能表示整数**
移码就是在真值X上加上一个常数（偏置值），通常取$2^n$
$[X]_移=2^n+x$
移码有以下特点：
1. **0的移码表示唯一**
2. 真值和它的移码表示只相差一个符号位
3. 移码全0时，对应真值的最小值$-2^n$；移码全1时，代表真值的最大值$2^n-1$
4. 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

## 2.1.4 整数的表示
### 1. 无符号整数的表示
一般在全是正数运算且不会出现负值的场合下使用，例如**内存地址、指针**
### 2. 带符号整数的表示
计算机中的带符号整数都用补码表示
$n$位带符号整数的表示范围是$-2^{n-1}\le{x}\le{2^{n-1}-1}$

# 2.2 运算方法和运算电路
## 2.2.1 基本运算部件
### 算术逻辑单元

完成**算术运算、逻辑运算和移位、求补**等功能
![请添加图片描述](https://img-blog.csdnimg.cn/fc1cdcc1b47643f4b3171e7d4e6604e8.jpeg)
> 1. ALU作为运算器的核心部件，属于组合逻辑电路
### 一位全加器
![在这里插入图片描述](https://img-blog.csdnimg.cn/d8059f2bbf1c4c40b0fc73cd38131865.jpeg)
### 串行加法器
![在这里插入图片描述](https://img-blog.csdnimg.cn/3316f2282d3441ac903a3a54bc8abe10.jpeg)
> 1 串行进位的并行加法器中，影响运算速度的关键因素是：进位传递的延迟

### 并行加法器
![在这里插入图片描述](https://img-blog.csdnimg.cn/3872c07969ad4b158c12ac2a9da20c49.jpeg)


##  2.2.2 定点数的移位运算
### 1. 算数移位
**算数移位的对象是有符号数，在移位过程中，符号位保持不变**
填补规则如下
||码制|填补|
|--|--|--|
|正数|原码、反码、补码|0|
|负数|原码|0|
||补码|左移补0、右移补1|
||反码|1|

1. 负数的补码中，最右边的1及其右边同原码，左边同反码。因此左移添0，右移添1
2. 没有发生精度丢失时，左移相当于乘以2，右移相当于除以2

> 1. 补码[X]_补=X1X2...Xn, X1为符号位，X2为最高数值位。则左移时，若X1!=X2,会丢失精度
> 2. 算术移位时，双符号位的移位操作只有低符号位需要参与，用于判断是否溢出

### 2. 逻辑移位
**逻辑移位将操作数视为无符号数**
统一补0
### 3. 循环移位
![请添加图片描述](https://img-blog.csdnimg.cn/5937b161344c494f80e6a6995d1f546d.png)
**带进位的循环移位：进位位CF参与循环**
## 2.2.3 定点数的加减法运算
运算时只需关心符号位和数值位，无需关心小数点位置
### 1. 补码的加减法运算
1. 加减法都转换为加法运算
2. 按照二进制运算规则计算，逢二进一
3. 符号位参与运算，在运算中直接得出
4. 高位丢弃，运算结果仍然为补码

```
假设机器字长8位，包含一位符号位，A=15，B=24，求[A+B]_补和[A-B]_补

A = 15 = 0000_1111
B = 24 = 0001_1000
-B = -24 = 1110_1000（B的补码，全部取反，再+1
A+B = 0010_0111 
A-B = 1111_0111
```
### 2. 补码加减法运算电路
一个数的补码为Y，那么这个数的负数的补码为$Y^{-1}+1$
因此在原加法器的Y输入端加n个反向器
加一个2选1多路选择器，用Sub控制，Sub=1时，做减法，实现$X+Y^{-1}+1$；Sub=0时，做加法，实现$X+Y$
> 8位加法器，无符号数x=69, y=38, 在该加法器中计算x-y，则两个输入端信息和输入的低位进位信息为：
> 无论有没有符号，都按照[x]补+[-y]补计算
> x = 0100_0101, y = 0010_0110，y通过反向器，则两个输入端应该为01000101和11011001
> 做减法，因此低位进位信息为 Sub = 1
### 3. 溢出判别方法
仅当两个**符号相同的数相加**或**符号相异的数相减**，才有可能产生溢出。
补码定点数加减运算判断溢出的方法有三种
#### 采用一个符号位
**两个操作数符号位相同，而结果符号位不同**，说明产生溢出。	

计算$A+B=S$，符号为$A_S,B_S,C_S$
逻辑表达式$V=A_SB_S(S_S)^{-1}+(A_S)^{-1}(B_S)^{-1}S_S$
$V=0$说明没有溢出，否则溢出
#### 采用双符号位
**用模四补码，运算结果的两个符号位相同，说明没有溢出；否则说明溢出**

|符号位|情况|
|---|---|
|00|正数|
|11|负数|
|01|上溢|
|10|下溢|

#### 采用一个符号位，根据进位情况判断
**如果符号位的进位$C_s$和最高数位的进位$C_1$相同，说明没有溢出；否则说明溢出**
![请添加图片描述](https://img-blog.csdnimg.cn/2e05919d8e104c789ef1d96b443d1ebd.png)
> 1. 在定点运算器中，无论采用双符号位还是单符号位，必须有：溢出判断电路，一般采用异或门实现
> 2. （18 408）R1=FFFF,FFFFH，R2=FFFFFFF0H。执行R1-R2后，OF和CF分别是？
> R1>R2（负数补码越大，代表真值越大），所以进位/借位标志CF=0
> -R2补码=0000,0010H，R1-R2结果中，最高数值位和符号位进位都是1，没有溢出，所以OF=0
## 2.2.4 定点数的乘除运算 *
![在这里插入图片描述](https://img-blog.csdnimg.cn/cda9c9d6c36244d882061f0258f609c7.png)

### 1. 定点数的乘法运算
乘法运算由累加和右移操作实现，可以分为**原码一位乘法**和**补码一位乘法**
#### 原码一位乘法
1. 乘积的符号单独计算，由操作数的符号位**异或**得到
2. 数值部分是两个操作数的绝对值之积
3. 部分积采用双符号位，避免溢出

```mermaid
flowchat
st=>start: 高位部分积用双符号位，初始为0；低位部分积为乘数
e=>end: 结果
op=>operation: 从乘数最低位判断
op1=>operation: 乘数最低位为0，则加上0
op2=>operation: 乘数最低位为1，则加上被乘数
cond=>condition: 重复n次
cond1=>condition: 是否为1
op3=>operation: 逻辑右移一位


st->op->cond1
cond1(yes)->op2
cond1(no)->op1
op1->op3
op2->op3
op3->cond
cond(no)->cond1
cond(yes)->e
```

举例
```
x = -0.1101, y = 0.1011 用原码一位乘法求 x*y

符号位：1^0 = 1
数值位：
(高位部分积)	（低位部分积/乘数)	(说明）
00.0000			1101
00.1011						最低位1，加上被乘数
--------
00.1011
00.0101			1110｜1		逻辑右移
00.0000						最低位0，加0
--------
00.0101						
00.0010			1111|01		逻辑右移
00.1011						最低位1，加上被乘数
--------
00.1101
00.0110			1111|101	逻辑右移
00.1011						最低位1，加上被乘数
--------
01.0001
00.1000			1111|1101	逻辑右移

至此已判断最低位4次 数值位为 00.10001111

结果 -0.10001111
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/33fc1966db56497fb4bb884e34a380ab.png)


#### 补码一位乘法（booth算法
1. 符号位参与运算，运算的数均用补码表示
2. 被乘数采用双符号位，乘数采用单符号位。部分积初始为0
3. 乘数末尾增设一位，初始为0
4. 根据y_n和y_{n+1}的值确定操作

|$y_n$（高位）|$y_{n+1}$（低位）|操作|
|---|---|---|
|0|0|部分积右移一位|
|1|1|部分积右移一位|
|0|1|部分积+$[X]_补$，右移一位|
|1|0|部分积+$[-X]_补$右移一位|
5. 移位按照补码右移规则进行
6. 进行$n+1$步操作，但第$n+1$步不再移位

举例
```
x = -0.1101, y = 0.1011 用补码一位乘法求 x*y

[x]补 = 11.0011	[-x]补=00.1101	[y]补=0.1011

(高位部分积)	（低位部分积/乘数)	(说明）
00.0000			0.1011|0	增添一位0
00.1101						1|0 +[-x]补
--------
00.1101
00.0110			10.101｜10	算数右移，小数点跟着动
							1｜1 算术右移
00.0011			010.10｜110	
11.0011						0｜1 +[x]补
--------
11.0110						
11.1011			0010.1｜0110	算术右移
00.1101							1|0 +[-x]补
--------
00.1000
00.0100			00010.|10110
11.0011							0｜1 +[x]补
--------
11.0111						不移动了这次

结果为 1.01110001
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/ddc59031623242898b49e25f3485d7c7.png)

![请添加图片描述](https://img-blog.csdnimg.cn/b10a8d68f28543b393198b2d1c249be1.png)
> 1. 数值位n位，原码一位乘法需要n次加法和移位；补码一位乘法需要n+1次加法，n次移位
> 2. 数值位n位，补码一位乘法得到乘积2n+1位（一位符号位）
> 3. （10真题）假设4个整数用8位补码表示，分别为$r_1$=FEH, $r_2$=F2H, $$r_3$=90H, $r_4$=F8H，若结果放在一个8位寄存器中，则两数相乘会溢出的是：（考察8位补码的表示范围：-128～127）
### 2. 定点数的除法运算
除法运算可以转换为**累加-逻辑左移**，分为**原码除法**和**补码除法**
#### 符号扩展
对于正数：符号位不变，所有扩展位填0
对于负数：原码表示时，所有扩展位填0；补码表示时，原有符号位移动到新的符号位上，然后扩展位填1（对于整数）或0（对于小数）
![请添加图片描述](https://img-blog.csdnimg.cn/0875db0827b44b5f821bd16e40807b90.png)

#### 原码除法（不恢复余数法
1. 商的符号由两个操作数的符号异或得到
2. 被除数减掉除数，余数为正时，商1，余数和商左移一位，再减去除数；余数为负时，商0，余数和商左移一位，再加上除数
3. 第n+1步余数为负时，需要加上|除数|得到正确的余数

举例

```
x = 0.1011, y = 0.1101 采用原码加减交替除法求x/y

商符 0^0=0
[x]补 = 0.1011,[y]补=0.1101,[-y]补=1.0011

被除数/余数			商			说明
0.1011				0.0000
1.0011							被除数减掉除数，即+[-y]补
--------
1.1110				0.000(0)	余数为负，商0
1.1100				0.00(0)0		左移一位
0.1101							加上除数
--------
0.1001							
0.1001				0.00(01)	余数为正，商1
1.0010				0.0(01)0	左移一位
1.0011							减掉除数
--------
0.0101							
0.0101				0.0(011)	余数为正，商1
0.1010				0.(011)0	左移一位
1.0011							减掉除数
--------
1.1101
1.1101				0.(0110)	余数为负，商0
1.1010				(0.110)0	左移一位
0.1101							加上除数
--------
0.0111
0.0111				(0.1101)	余数为正，商1

结果为0.1101，余数为0.0111*2^{-4}
```
#### 补码除法运算
1. 符号位参与运算，所有数都用补码表示
2. 被除数和除数同号，则被除数减掉除数；被除数和除数异号，则被除数加上除数
3. 余数和除数同号，商1，余数左移一位减掉除数；余数和除数异号，商0，余数左移一位加上除数
4. 重复步骤3 n次
5. 一般末尾恒置1

举例
```
x = 0.1000, y = -0.1011 采用补码加减交替法球x/y

[x]补 = 00.1000, [y]补 = 11.0101, [-y]补 = 00.1011

被除数/余数			商			说明
00.1000				0.0000		被除数双符号位，商单符号位
11.0101							被除数和除数异号，被除数加上除数
--------
11.1101				0.000(1)	余数和除数同号，商1
11.1010				0.00(1)0	左移一位
00.1011							减掉除数
--------
00.0101				0.00(10)	余数和除数异号，商0
00.1010				0.0(10)0	左移一位
11.0101							加上除数
--------
11.1111				0.0(101)	余数和除数同号，商1
11.1110				0.(101)0	左移一位
00.1011							减掉除数
--------
00.1001				0.(1010)	余数和除数异号，商0
01.0010				(1.010)0	左移一位
11.0101							加上除数
--------
00.0111				(1.0101)	末尾恒置1
余数						商

因此答案为[x/y]补=1.0101	余数 0.0111*2^{-4}
```
## 2.2.5 C语言中的整数类型以及类型转换
C语言的定点整数都是采用**补码**存储的
### 1. 有符号数和无符号数的转换
**强制类型转换的结果保持位值不变，仅仅改变解释这些位的方法**
例如
```c
int main(){
	short x = -4321;
	unsigned short y = (unsigned short) x;
}
```
在采用补码的机器上，上述代码结果是`x=-4321, y=61215`
写出二进制即可得出结果
### 2. 不同字长整数之间的转换
大字长向小字长变量强制类型转换时，**高位截断，低位直接赋值**
小字长向大字长变量强制类型转换时，**无符号整数进行0扩展，有符号整数进行符号位扩展**
## 2.2.6 数据的存储和排列
### 1. 数据的大端和小端存储
多字节数据存放在连续的字节序列中，根据各个字节排列的顺序，可以分为大端和小端存储
1. 大端方式：最高有效字节在前
2. 小端方式：最低有效字节在前

```
01 23 45 67H
高->低
			0800H	0801H	0802H	0803H
大端：		01		23		45		67
小端：		67		45		23		01
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/39a4351c76bd403fa6de99c6eb6c2e23.png)


### 2. 数据按照边界对齐方式存储
1. 边界对齐方式：可能浪费存储空间，但是提高了存取指令和取数的速度
2. 数据不按边界对齐：可以充分利用存储空间，但是影响了指令的执行效率。

![在这里插入图片描述](https://img-blog.csdnimg.cn/711c97783de1450a8d3de0e341c96702.png)


# 2.3 浮点数的表示和运算
## 2.3.1 浮点数的表示格式
浮点数表示法是以合适形式将比例因子表示在数据中，让小数点的位置根据需要浮动
在位数有限的情况下，扩大了数的表示范围，保持了有效精度
### 1. 浮点数的表示格式
通常浮点数表示为：$N=(-1)^S*M*R^E$
1. 其中$S$取0或1，用来决定浮点数的符号
2. $M$是一个二进制定点小数，称为**尾数**，一般用**定点原码小数**表示
3. $E$是一个二进制定点整数，称为**阶码**或**指数**，用**移码**表示
4. $R$是隐含的**基数**，可以约定为2、4、16等

以下是一个32位短浮点数格式的举例
|数符（1位）|阶码（7位）|尾数（24位）|
|----|----|----|
### 2. 浮点数的表示范围（大纲删
原码关于原点对称，因此浮点数的范围也关于原点对称
1. 运行结果大于最大正数称为**正上溢**，小于最小负数称为**负上溢**。上溢发生时，必须中断运算操作，进行溢出处理
2. 运行结果小于最小正数称为**正下溢**，大于最大负数称为**负下溢**。下溢时，计算机将结果看作机器0处理
### 3. 浮点数的规格化
规格化操作：调整一个非规格化浮点数的**尾数和阶码**，使非零的浮点数在尾数的最高数位上保证是一个有效值
1. 左规：尾数左移一位，阶码减一
2. 右规：尾数右移一位，阶码加一

规格化保证**尾数是定点小数，最高位为有效数位**

> 1. 采用规格化的浮点数主要目的：提高精度
> 2. 补码表示的规格化小数的尾数，数值最高位和符号位不同
> 3. 原码表示的规格化小数的尾数，基数为2时，最高位一定为1；基数为4时，最高两位不全为0

### 4. IEEE 754 标准
IEEE 754 浮点数格式包括：

32位单精度（**阶码偏置127**）
|数符（1位）|阶码（8位）|尾数（23位）|
|----|----|----|

64位双精度（**阶码偏置1023**）
|数符（1位）|阶码（11位）|尾数（52位）|
|----|----|----|

**对于规格化的二进制浮点数，数值位的最高位总是1，为了使尾数多表示一位有效位，将这个1隐藏，称为隐藏位**
因此在IEEE 754 标准中，规格化短浮点数的真值为：$(-1)^S*1.M*2^{E-127}$；规格化长浮点数的真值为：$(-1)^S*1.M*2^{E-1023}$

IEEE754标准浮点数阶码全0（-128）或1（-127）时有特别的解释
![在这里插入图片描述](https://img-blog.csdnimg.cn/96992838b61d4d5aadb179230e6319eb.heic)
![在这里插入图片描述](https://img-blog.csdnimg.cn/922e8325b26b4b0aab806cfacc4c1a96.png)
> 1. (11 408) float数据用IEEE754单精度浮点数格式表示，x=-8.25，表示为？
> 一位符号 S=1
> 8.25 = 1000.01	规格化为 1.00001*2^3
> 8位阶码：3+127 = 130 = 1000,0010
> 23位尾数 0000,10... (小数点前1省略
> 拼起来：1100,0001,0000,0100,0000,0000,0000,0000 = C1040000H
> 2. (12 408) 32位float使用IEEE754单精度浮点数表示，最大正整数值？
> 数符0，阶码8位，取254最大值（255用作表示正无穷，不能取），尾数全1（23位），加上隐藏的1.
> $2^{254-127}*(1+(1-2^{-23}))=2^{127}*(2-2^{-23})=2^{128}-2^{104}$

### 5. 定点表示和浮点表示的区别
1. 表示范围：字长相同时，浮点表示法所表示的范围远大于定点表示法
2. 精度：浮点表示法降低了精度
3. 数的运算：浮点运算需要算尾数、阶码，需要规格化，更加复杂
4. 溢出：浮点运算时，尾数超出范围、规格化后阶码超出范围才是真正溢出了

## 2.3.2 浮点数的加减运算
浮点数运算的特点是**阶码运算和尾数运算分开**
1. 对阶：使两个数阶码相等，小阶向大阶看齐
2. 尾数求和
3. 规格化：左规，阶码-1；右规，阶码+1
4. 舍入：右规时会舍弃低位，一般将低位移出的两位保留，参加运算后结果舍入。包括：**0舍1入（类似四舍五入）、恒置1、截断法（丢弃所有位）**
5. 溢出判断：主要判断**阶码是否溢出**
6. C语言的浮点数类型：`char->int->long->double`和`float->double`过程中不会溢出，`int->float`可能舍入影响精度

> 1. 浮点数加减法中，对阶时，只会出现右规（尾数右移，阶码增大）的情况，不会出现左规
> 2. 舍入是浮点数的概念，定点数没有舍入的概念
> 3. 浮点数舍入，在规格化和对阶两个过程中可能产生

![在这里插入图片描述](https://img-blog.csdnimg.cn/676ec665fd674698a9dfa6e20ae83d57.png)
# 408真题
（17 408）

- IEEE754标准
- RISC、CISC
- **CF标志：转化为补码计算，A+B时，进位1，CF=1，进位0，CF=0；A-B时，进位1，CF=0，进位0，CF=1**

![在这里插入图片描述](https://img-blog.csdnimg.cn/184c312aa2bd41d8a7ca7f2f151be794.jpeg)
